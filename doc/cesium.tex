% (C) 2012, William Hart
%   This file is part of Cesium.

%   Cesium is free software; you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation; either version 2 of the License, or
%   (at your option) any later version.

%   Cesium is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.

%   You should have received a copy of the GNU General Public License
%   along with Cesium; if not, write to the Free Software
%   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{cesium}
{ 
  morekeywords={while,do,if,then,else,end,type},
  morekeywords={none,int8,int16,int32,int64,int},
  morekeywords={uint8,uint16,uint32,uint64},
  morekeywords={uint,char,string,double,float},
  morekeywords={true,false,bool},
  morekeywords={i,u,i8,i16,i32,i64,u8,u16,u32,u64,f,e,E},
  morecomment=[s]{/*\ }{*/},        
  morecomment=[s]{/**}{*/},
  sensitive=true,
  morestring=[b]",
  morestring=[b]',
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{w.b.hart@maths.warwick.ac.uk}

\title{Cesium : A New Language}
\author{William B. Hart}

\begin{document}
\lstset{
  language=cesium,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Cesium is a new programming language designed primarily for efficiency, easy interface with C libraries
and with a straightforward high-level syntax. It uses the LLVM Jit to give very performant code, even
when run in interactive mode. The language is polymorphic, statically typed (with type inference) and
imperative in style, with some functional features.

The language fills a niche between Python and C. Python is not terribly performant, but has a very
simple and flexible syntax. C is fiddly and low level, statically compiled and not interactive, but very 
fast. 

Cesium is inspired by Julia, but is more suited to computer algebra, rather than numerical tasks.
Of course Cesium can be used as a general purpose language, but design decisions are influenced by the
desire to make it useful to a certain class of mathematical/computational people.

\section{The Cesium interpreter}

The Cesium interpreter is started by typing \code{./cs} at the command line.

When the interpreter starts, a prompt is displayed ready to accept Cesium code.

If you type an expression and press enter, Cesium immediately executes the expression and a return 
value is displayed. If there is no return value, \code{none} is printed.

Note that end-of-lines are significant in Cesium. In many cases they can be elided by addition of
certain keywords. However, in general, statements must finish with an end-of-line.

\section{Code comments}

Cesium allows you to add comments to your code, which are ignored by the parser. For example, 
\code{/* this is a comment */}.

Comments are allowed anywhere that a space is allowed.

\begin{lstlisting}
if 1 < 2 /* check if 1 is less than 2 */
   3 /* if it is, return 3 */
else
   4 /* if not, return 4 */
end /* end of if */
\end{lstlisting}

\section{Literals}

We first describe how to enter various types of constant literals in Cesium.  

\subsection{Integer literals}

Here are some examples of signed and unsigned integers in Cesium:

\begin{lstlisting}
1234
12u8
109i8
278009804u
234567i32
\end{lstlisting}

Integers with no suffix are signed and either 32 or 64 bits, depending on whether a 32 or 
64 bit binary of Cesium is being used.

Integers which are unsigned are given the suffix \code{u}. 

The other suffixes, e.g. \code{i8}, \code{u32}, etc., specify whether the number is signed
(with a \code{i}) or unsigned (with a \code{u}) and how many bits the type is. The valid 
numbers of bits are \code{8, 16, 32, 64}.

For example, the literal \code{109i8} is the integer \code{109} stored as a signed 8 bit 
value.

The suffixes are necessary in Cesium because it uses type inference to infer the type of a
value from the value itself. In the case of numbers this is not possible without the extra 
annotation. 

In practice, only unannotated types are required unless one has some specific bit fiddling 
to do or if one is interfacing with a C program which makes use of specific types.

The Cesium types for integer values are \code{int8}, \code{uint8}, \code{int16}, 
\code{uint16}, etc., depending on the suffix the value has.

\subsection{Floating point literals}

There are two types of floating point values in Cesium, \code{float} and \code{double} values.

Floating point values must have a decimal point and have an optional exponent. The exponents 
begin with an optional sign, followed by an integer. 

Without a suffix, floating point values are considered to be double precision floating point 
values. However, if they have the suffix \code{f} they are considered to be single precision 
floats.

Here are some example floating point values:

\begin{lstlisting}
1.0
2.1f
123.4
1.3e+12
1.4E-11f
\end{lstlisting}

For example, \code{1.4E-11f} is the single precision floating point value $1.4\times 10^{-11}$.

\subsection{Character literals}

Cesium has a \code{char} type for single ASCII characters. To represent a character one simply
wraps it in single quote marks.

\begin{lstlisting}
'c'
's'
','
' '
\end{lstlisting}

Some special characters are also available. These characters all begin with a backslash:

\begin{lstlisting}
'\n' /* new line */
'\r' /* carriage return */
'\t' /* tab */
'\0' /* null character */
'\\' /* backslash */
'\"' /* double quotes */
'\'' /* single quotes */
\end{lstlisting}

\subsection{String literals}

One can represent strings in Cesium by putting them between double quotation marks:

\begin{lstlisting}
"this is a string"
"123"
" %51"
\end{lstlisting}

To include a double quotation mark in a string, it must be escaped with a backslash:

\begin{lstlisting}
"this \"string\" contains double quotes"
\end{lstlisting}

The type of a string value in Cesium is \code{string}.

\section{Expressions}

When an expression is entered at the Cesium prompt, it immediately evaluates the 
expression and prints the result. For example, typing the expression \code{1 + 1} at
the prompt results in the value \code{2}.

We now discuss the various ways of constructing expressions in Cesium.

\subsection{Tuples}

A tuple of values can be entered by separating the individual expressions by commas and
wrapping in parentheses. Note that a tuple with only one entry must have a comma before
the final parenthesis to distinguish it from a set of parentheses around an expression
which are acting as a grouping rather than as a tuple constructor.

Here are some examples of tuples expressions:

\begin{lstlisting}
(1, 2, 3)
(0,)
(3, 'c', "string", (2.3, 1.1f, 3u8))
\end{lstlisting}

A tuple can be thought of as an anonymous data type in Cesium. It can contain inhomogeneous
data, i.e. the types of the expressions in the tuple do not need to be the same. This is 
different to arrays, which must have homogeneous data. However, unlike arrays, tuples cannot 
be accessed by index. To extract values from a tuple, one needs to use tuple unpacking, described 
later.

The type of a tuple value is given by a tuple of types, e.g. the tuple \code{(1, 'c', "string")}
has type \code{(int, char, string)}.

\subsection{Binary arithmetic operators}

To perform computations with values, one has the binary arithmetic operators \code{+}, \code{-},
\code{*}, \code{/} and \code{%}, representing binary addition, subtraction, multiplication,
division and remainder, respectively. 

These operators are defined for each of the integer and floating point types. 

The ordinary mathematics rules for operator precedence and associativity apply. But to evaluate
in a different order, one can group using parentheses.

Here are some example expressions using the arithmetic operators:

\begin{lstlisting}
1 + 2
1 - 2*3 - (4 - 7*6)
2.3 / 4.0
12.7 % 1.2
11 % 3
\end{lstlisting}

\subsection{Binary relational operators}

A binary relational operator takes two values, performs some comparison on them and then returns
a \code{bool} depending on the result of the comparison.

The relational operators available in Cesium are \code{<}, \code{>}, \code{<=}, \code{>=}, 
\code{==} and \code{!=}.

Here are some expression using these operators:

\begin{lstlisting}
1 < 2
12.1 >= 15.0
7 != 7
4i8 == 4i8
\end{lstlisting}

Each of them returns either \code{true} or \code{false} depending on whether the stated relation
holds or not.

\subsection{Ternary ``if'' expressions}

An \code{if} expression in Cesium is an expression which takes one of two values, depending on the
outcome of a comparison. It is best illustrated with an example:

\begin{lstlisting}
if 1 < 2 then 3 else 4 end
\end{lstlisting}

This expression has the value \code{3} if \code{1 < 2}, otherwise it has the value \code{4}.

There is no requirement that an \code{if} expression must be all on one line. For example,
the following is equivalent to the above.

\begin{lstlisting}
if 1 < 2 then 
  3 
else 
  4 
end
\end{lstlisting}

This format also allows for additional lines of code to be inserted in each branch (see
\code{if} statements later in the documentation for examples). However, the (final) expressions
in each branch are restricted to having the same type, which then becomes the type of the entire 
\code{if} expression. Thus, for example, the type of the \code{if} expression in the above 
example is \code{int}.

For convenience, the \code{then} keyword may be elided in the multiline version:

\begin{lstlisting}
if 1 < 2
  3 
else 
  4 
end
\end{lstlisting}

\end{document}
