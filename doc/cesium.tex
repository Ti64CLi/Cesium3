% (C) 2012, William Hart
%   This file is part of Cesium.

%   Cesium is free software; you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation; either version 2 of the License, or
%   (at your option) any later version.

%   Cesium is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.

%   You should have received a copy of the GNU General Public License
%   along with Cesium; if not, write to the Free Software
%   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{cesium}
{ 
  morekeywords={while,do,if,then,else,end,type},
  morekeywords={none,int8,int16,int32,int64,int},
  morekeywords={uint8,uint16,uint32,uint64},
  morekeywords={uint,char,string,double,float},
  morekeywords={true,false,bool},
  morekeywords={u,i8,i16,i32,i64,u8,u16,u32,u64,f,e,E},
  morecomment=[s]{/*\ }{*/},        
  morecomment=[s]{/**}{*/},
  sensitive=true,
  morestring=[b]",
  morestring=[b]',
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{w.b.hart@maths.warwick.ac.uk}

\title{Cesium : A New Language}
\author{William B. Hart}

\begin{document}
\lstset{
  language=cesium,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Cesium is a new programming language designed primarily for efficiency, easy interface with C libraries
and with a straightforward high-level syntax. It uses the LLVM Jit to give very performant code, even
when run in interactive mode. The language is polymorphic, statically typed (with type inference) and
imperative in style, with some functional features.

The language fills a niche between Python and C. Python is not terribly performant, but has a very
simple and flexible syntax. C is fiddly and low level, statically compiled and not interactive, but very 
fast. 

Cesium is inspired by Julia, but is more suited to computer algebra, rather than numerical tasks.
Of course Cesium can be used as a general purpose language, but design decisions are influenced by the
desire to make it useful to a certain class of mathematical/computational people.

\section{The Cesium interpreter}

The Cesium interpreter is started by typing \code{./cs} at the command line.

When the interpreter starts, a prompt is displayed ready to accept Cesium code.

If you type an expression and press enter, Cesium immediately executes the expression and a return 
value is displayed. If there is no return value, \code{none} is printed.

Note that end-of-lines are significant in Cesium. In many cases they can be elided by addition of
certain keywords. However, in general, statements must finish with an end-of-line.

\section{Code comments}

Cesium allows you to add comments to your code, which are ignored by the parser. For example, 
\code{/* this is a comment */}.

Comments are allowed anywhere that a space is allowed.

\begin{lstlisting}
if 1 < 2 /* check if 1 is less than 2 */
   3 /* if it is, return 3 */
else
   4 /* if not, return 4 */
end /* end of if */
\end{lstlisting}

\section{Literals}

We first describe how to enter various types of constant literals in Cesium.  

\subsection{Integer literals}

Here are some examples of signed and unsigned integers in Cesium:

\begin{lstlisting}
1234
12u8
109i8
278009804u
234567i32
\end{lstlisting}

Integers with no suffix are signed and either 32 or 64 bits, depending on whether a 32 or 
64 bit binary of Cesium is being used.

Integers which are unsigned are given the suffix \code{u}. 

The other suffixes, e.g. \code{i8}, \code{u32}, etc., specify whether the number is signed
(with a \code{i}) or unsigned (with a \code{u}) and how many bits the type is. The valid 
numbers of bits are \code{8, 16, 32, 64}.

For example, the literal \code{109i8} is the integer \code{109} stored as a signed 8 bit 
value.

The suffixes are necessary in Cesium because it uses type inference to infer the type of a
value from the value itself. In the case of numbers this is not possible without the extra 
annotation. 

In practice, only unannotated types are required unless one has some specific bit fiddling 
to do or if one is interfacing with a C program which makes use of specific types.

The Cesium types for integer values are \code{int8}, \code{uint8}, \code{int16}, 
\code{uint16}, etc., depending on the suffix the value has.

\subsection{Floating point literals}

There are two types of floating point values in Cesium, \code{float} and \code{double} values.

Floating point values must have a decimal point and have an optional exponent. The exponents 
begin with an optional sign, followed by an integer. 

Without a suffix, floating point values are considered to be double precision floating point 
values. However, if they have the suffix \code{f} they are considered to be single precision 
floats.

Here are some example floating point values:

\begin{lstlisting}
1.0
2.1f
123.4
1.3e+12
1.4E-11f
\end{lstlisting}

For example, \code{1.4E-11f} is the single precision floating point value $1.4\times 10^{-11}$.

\subsection{Character literals}

Cesium has a \code{char} type for single ASCII characters. To represent a character one simply
wraps it in single quote marks.

\begin{lstlisting}
'c'
's'
','
' '
\end{lstlisting}

Some special characters are also available. These characters all begin with a backslash:

\begin{lstlisting}
'\n' /* new line */
'\r' /* carriage return */
'\t' /* tab */
'\0' /* null character */
'\\' /* backslash */
'\"' /* double quotes */
'\'' /* single quotes */
\end{lstlisting}

\subsection{String literals}

One can represent strings in Cesium by putting them between double quotation marks:

\begin{lstlisting}
"this is a string"
"123"
" %51"
\end{lstlisting}

To include a double quotation mark in a string, it must be escaped with a backslash:

\begin{lstlisting}
"this \"string\" contains double quotes"
\end{lstlisting}

The type of a string value in Cesium is \code{string}.

\section{Expressions}

When an expression is entered at the Cesium prompt, it immediately evaluates the 
expression and prints the result. For example, typing the expression \code{1 + 1} at
the prompt results in the value \code{2}.

We now discuss the various ways of constructing expressions in Cesium.

\subsection{Tuples}

A tuple of values can be entered by separating the individual expressions by commas and
wrapping in parentheses. Note that a tuple with only one entry must have a comma before
the final parenthesis to distinguish it from a set of parentheses around an expression
which are acting as a grouping rather than as a tuple constructor.

Here are some examples of tuples expressions:

\begin{lstlisting}
(1, 2, 3)
(0,)
(3, 'c', "string", (2.3, 1.1f, 3u8))
\end{lstlisting}

A tuple can be thought of as an anonymous data type in Cesium. It can contain inhomogeneous
data, i.e. the types of the expressions in the tuple do not need to be the same. This is 
different to arrays, which must have homogeneous data. However, unlike arrays, tuples cannot 
be accessed by index. To extract values from a tuple, one needs to use tuple unpacking, described 
later.

The type of a tuple value is given by a tuple of types, e.g. the tuple \code{(1, 'c', "string")}
has type \code{(int, char, string)}.

\subsection{Binary arithmetic operators}

To perform computations with values, one has the binary arithmetic operators \code{+}, \code{-},
\code{*}, \code{/} and \code{%}, representing binary addition, subtraction, multiplication,
division and remainder, respectively. 

These operators are defined for each of the integer and floating point types. 

The ordinary mathematics rules for operator precedence and associativity apply. But to evaluate
in a different order, one can group using parentheses.

Here are some example expressions using the arithmetic operators:

\begin{lstlisting}
1 + 2
1 - 2*3 - (4 - 7*6)
2.3 / 4.0
12.7 % 1.2
11 % 3
\end{lstlisting}

\subsection{Binary relational operators}

A binary relational operator takes two values, performs some comparison on them and then returns
a \code{bool} depending on the result of the comparison.

The relational operators available in Cesium are \code{<}, \code{>}, \code{<=}, \code{>=}, 
\code{==} and \code{!=}.

Here are some expression using these operators:

\begin{lstlisting}
1 < 2
12.1 >= 15.0
7 != 7
4i8 == 4i8
\end{lstlisting}

Each of them returns either \code{true} or \code{false} depending on whether the stated relation
holds or not.

\subsection{Ternary ``if'' expressions}

An \code{if} expression in Cesium is an expression which takes one of two values, depending on the
outcome of a comparison. It is best illustrated with an example:

\begin{lstlisting}
if 1 < 2 then 3 else 4 end
\end{lstlisting}

This expression has the value \code{3} if \code{1 < 2}, otherwise it has the value \code{4}.

There is no requirement that an \code{if} expression must be all on one line. For example,
the following is equivalent to the above.

\begin{lstlisting}
if 1 < 2 then 
  3 
else 
  4 
end
\end{lstlisting}

This format also allows for additional lines of code to be inserted in each branch (see
\code{if} statements later in the documentation for examples). 

The expressions in each branch of an \code{if} expression must have the same type. This then 
becomes the type of the entire expression. Thus, for example, the type of the \code{if} 
expression in the above example is \code{int}.

For convenience, the \code{then} keyword may be elided in the multiline version of an \code{if}
expression:

\begin{lstlisting}
if 1 < 2
  3 
else 
  4 
end
\end{lstlisting}

\section{Variables and assignment}

\subsection{Global variables}

To define a variable in Cesium, one uses an assignment to assign a given value to that variable.
It is not necessary to declare variables in advance. They begin to exist at the moment they are
first assigned a value.

Here are some examples of assignment:

\begin{lstlisting}
i = 1
mytup = (1, 'c', "string")
v = i + 1
s = if 1 < 2 then 3 else 4 end
\end{lstlisting}

If a variable is defined at the top level (at the Cesium prompt), it is called a global variable
and its value can be used or changed anywhere after that point.

\subsection{Tuple assignment}

Sometimes it is convenient to be able to assign a whole lot of values at once. This can be done
with tuple assignment. For example, the following code defines variables \code{a}, \code{b} and 
\code{c} (if they don't already exist), and assigns the values \code{0}, \code{1} and 
\code{"string"}, respectively, to them:

\begin{lstlisting}
(a, b, c) = (0, 1, "string")
\end{lstlisting}

Note that tuple assignment is done efficiently by the compiler without actually creating a tuple.
It's simply syntactic sugar for multiple assignment.

\subsection{Tuple unpacking}

Sometimes one has a value which is a tuple and one wants to extract the values individually. This
is called tuple unpacking. 

For example, suppose that, at some point in our code, we have:

\begin{lstlisting}
t = (0, 1, "string")
\end{lstlisting}

We can extract the three values in the tuple \code{t} as follows:

\begin{lstlisting}
(a, b, c) = t
\end{lstlisting}

Now, \code{a} will have the value \code{0}, \code{b} the value \code{1} and \code{c} the value 
\code{"string"}.

Of course, the compiler does not actually create a tuple on the left hand side. It merely assigns
the three values from inside the tuple to the given variables.

Tuple assignment and unpacking can be combined, e.g.

\begin{lstlisting}
(a, b, (c, d)) = (1, 2, (3, 4))
\end{lstlisting}

Here tuple assignment is used to assign the values of \code{a} and \code{b} without creating a
tuple. Then the tuple \code{(3, 4)} is created and unpacked using tuple unpacking into \code{c}
and \code{d}. 

The compiler could optimise this case further by not creating the tuple \code{(3, 4)} and simply
assigning the values directly to \code{c} and \code{d}. However, this is not important as the
code above could also be written as follows, achieving the same thing efficiently:

\begin{lstlisting}
(a, b, c, d) = (1, 2, 3, 4)
\end{lstlisting}

\section{Control flow statements}

The path through a program is directed by control flow statements. We now discuss the various 
control flow statements available in Cesium.

\subsection{The ``if'' statement}

The \code{if} statement executes a series of statements if a given condition is true.

Here is an example of code fragment incorporating an \code{if} statement:

\begin{lstlisting}
i = 1
j = 2
if i < 2
   j = j + 1
   i = j + 3
end
\end{lstlisting}

As with an \code{if} expression, the condition can be followed by the keyword \code{then}, and if 
the code that is to be executed is a simple statement, the entire thing can be written on one line:

\begin{lstlisting}
i = 1
if i < 2 then i = 3 end
\end{lstlisting}

No value is returned by an \code{if} statement, and so \code{none} will be printed after
evaluating an \code{if} statement at the Cesium prompt.

\subsection{The ``if..else'' statement}

The \code{if.. else} statement executes the statements in one of two branches, depending on a given
condition.

Here is an example of code fragment incorporating an \code{if} statement:

\begin{lstlisting}
i = 1
j = 2
if i < 2
   j = j + 1
   i = j + 3
else
   i = 4
end
\end{lstlisting}

Note that the branch of an \code{if} statement does not define a new lexical scope. Thus
variables defined inside the \code{if} statement also exist outside it.

As with the \code{if} statement and \code{if} expression, the condition can be followed by the keyword
\code{then}, and if each branch only contains a single simple statement, then the entire thing can
be written on one line:

\begin{lstlisting}
i = 1
if i < 2 then i = 3 else i = 4 end
\end{lstlisting}

No value is returned by an \code{if..else} statement, and so \code{none} will be printed after
evaluating an \code{if..else} statement at the Cesium prompt.

Note that the branches of an \code{if..else} statement do not define a new lexical scope. Thus
variables defined inside a branch of an \code{if..else} statement also exist outside the statement.

Recall that an \code{if..else} statement whose branches both end in expressions (which must be of 
the same type) is called an \code{if} expression. An \code{if} expression does return a value, whose 
type is the same as that of the two expressions. 

Here is an example of a multi-line \code{if} expression.

\begin{lstlisting}
i = 1
j = 2
if i < 2
   j = j + 1
   i + j
else
   i = 4
   7
end
\end{lstlisting}

In this example, the \code{if} expression will have the value \code{4} because the first branch is 
taken and the final expression in that branch is \code{i + j}, which has the value \code{4}.

\subsection{The ``while'' statement}

A simple loop in Cesium can be obtained with the \code{while} statement. It continues to execute its
body in a loop so long as a given condition is true.

Here is a simple example of a \code{while} loop:

\begin{lstlisting}
i = 0
s = 0
while i < 1000000 do
   s = s + i
   i = i + 1
end
\end{lstlisting}

If there is only a single simple expression in the body of a while loop, the entire thing can be
written on a single line. 

In the multiline version, the \code{do} keyword can be elided. Thus the example above can be written:

\begin{lstlisting}
i = 0
s = 0
while i < 1000000
   s = s + i
   i = i + 1
end
\end{lstlisting}

A \code{while} statement does not return a value, and so \code{none} is printed if one is evaluated
at the Cesium prompt.

\end{document}
