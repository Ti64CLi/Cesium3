% (C) 2012, William Hart
%   This file is part of Cesium.

%   Cesium is free software; you can redistribute it and/or modify
%   it under the terms of the GNU General Public License as published by
%   the Free Software Foundation; either version 2 of the License, or
%   (at your option) any later version.

%   Cesium is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%   GNU General Public License for more details.

%   You should have received a copy of the GNU General Public License
%   along with Cesium; if not, write to the Free Software
%   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{color}
\usepackage{textcomp}
\usepackage{listings}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}
\newcommand{\code}{\lstinline}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\lstdefinelanguage{cesium}
{ 
  morekeywords={while,do,if,then,else,end,type},
  morekeywords={none,int,uint,char,string,double,float},
  morekeywords={true,false,bool},
  morekeywords={d,f,e,E,U,u},
  morecomment=[s]{/*\ }{*/},        
  morecomment=[s]{/**}{*/},
  sensitive=true,
  morestring=[b]",
  morestring=[b]',
}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{w.b.hart@maths.warwick.ac.uk}

\title{Cesium : A New Language}
\author{William B. Hart}

\begin{document}
\lstset{
  language=cesium,
  keywordstyle=\bfseries\ttfamily\color[rgb]{0,0.6,0.4},
  identifierstyle=\ttfamily\color[rgb]{0,0.2,0.8},
  commentstyle=\color[rgb]{0.8,0.05,1},
  stringstyle=\color[rgb]{0.8,0.1,0.1},
  basicstyle=\ttfamily,
  showstringspaces=false,
}
\maketitle
\tableofcontents

\section{Introduction}

Cesium is a new programming language designed primarily for efficiency, easy interface with C libraries
and with a straightforward high-level syntax. It uses the LLVM Jit to give very performant code, even
when run in interactive mode. The language is polymorphic, statically typed (with type inference) and
imperative in style, with some functional features.

The language fills a niche between Python and C. Python is not terribly performant, but has a very
simple and flexible syntax. C is fiddly and low level, statically compiled and not interactive, but very 
fast. 

Cesium is inspired by Julia, but is more suited to computer algebra, rather than numerical tasks.
Of course Cesium can be used as a general purpose language, but design decisions are influenced by the
desire to make it useful to a certain class of mathematical/computational people.

\section{The Cesium interpreter}

The Cesium interpreter is started by typing \code{./cs} at the command line.

When the interpreter starts, a prompt is displayed ready to accept Cesium code.

If you type an expression and press enter, Cesium immediately executes the expression and a return 
value is displayed. If there is no return value, \code{none} is printed.

Note that end-of-lines are significant in Cesium. In some cases they can be replaced with
certain keywords. However, in general, statements must finish with an end-of-line.

\section{Code comments}

Cesium allows you to add comments to your code, which are ignored by the parser. For example, 
\code{/* this is a comment */}.

Comments are allowed anywhere that a space is allowed.

\begin{lstlisting}
if 1 < 2 /* check if 1 is less than 2 */
   3 /* if it is, return 3 */
else
   4 /* if not, return 4 */
end /* end of if */
\end{lstlisting}

\section{Literals}

We first describe how to enter various types of constant literals in Cesium.  

\subsection{Integer literals}

Here are some examples of signed and unsigned integers in Cesium:

\begin{lstlisting}
1234
1234U
123u
\end{lstlisting}

Integers with no suffix are signed and either 32 or 64 bits, depending on whether a 32 or 
64 bit binary of Cesium is being used.

Integers with the suffix \code{U} or \code{u} are unsigned 32 or 64 bit integers.

\subsection{Floating point literals}

There are two types of floating point values in Cesium, \code{float} and \code{double} values.

Floating point values must have a decimal point and have an optional exponent. The exponents 
begin with an optional sign, followed by an integer. 

Without a suffix or with the suffix \code{d}, floating point values are considered to be double 
precision floating point values. However, if they have the suffix \code{f} they are considered 
to be single precision floats.

Here are some example floating point values:

\begin{lstlisting}
1.0
2.1f
1.2d
123.4
1.3e+12
1.4E-11f
\end{lstlisting}

For example, \code{1.4E-11f} is the single precision floating point value $1.4\times 10^{-11}$.

\subsection{Character literals}

Cesium has a \code{char} type for single ASCII characters. To represent a character one simply
wraps it in single quote marks.

\begin{lstlisting}
'c'
's'
','
' '
\end{lstlisting}

Some special characters are also available. These characters all begin with a backslash:

\begin{lstlisting}
'\n' /* new line */
'\r' /* carriage return */
'\t' /* tab */
'\0' /* null character */
'\\' /* backslash */
'\"' /* double quotes */
'\'' /* single quotes */
\end{lstlisting}

\subsection{String literals}

One can represent strings in Cesium by putting them between double quotation marks:

\begin{lstlisting}
"this is a string"
"123"
" %51"
\end{lstlisting}

To include a double quotation mark in a string, it must be escaped with a backslash:

\begin{lstlisting}
"this \"string\" contains double quotes"
\end{lstlisting}

The type of a string value in Cesium is \code{string}.

\section{Expressions}

When an expression is entered at the Cesium prompt, it immediately evaluates the 
expression and prints the result. For example, typing the expression \code{1 + 1} at
the prompt results in the value \code{2}.

We now discuss the various ways of constructing expressions in Cesium.

\subsection{Tuples}

A tuple of values can be entered by separating the individual expressions by commas and
wrapping in parentheses. Note that a tuple with only one entry must have a comma before
the final parenthesis to distinguish it from a set of parentheses around an expression
which are acting as a grouping rather than as a tuple constructor.

Here are some examples of tuples expressions:

\begin{lstlisting}
(1, 2, 3)
(0,)
(3, 'c', "string", (2.3, 1.1f, 3u8))
\end{lstlisting}

A tuple can be thought of as an anonymous data type in Cesium. It can contain inhomogeneous
data, i.e. the types of the expressions in the tuple do not need to be the same. This is 
different to arrays, which must have homogeneous data. However, unlike arrays, tuples cannot 
be accessed by index. To extract values from a tuple, one needs to use tuple unpacking, described 
later.

The type of a tuple value is given by a tuple of types, e.g. the tuple \code{(1, 'c', "string")}
has type \code{(int, char, string)}.

\subsection{Binary arithmetic operators}

To perform computations with values, one has the binary arithmetic operators \code{+}, \code{-},
\code{*}, \code{/} and \code{%}, representing binary addition, subtraction, multiplication,
division and remainder, respectively. 

These operators are defined for each of the integer and floating point types. 

The ordinary mathematics rules for operator precedence and associativity apply. But to evaluate
in a different order, one can group using parentheses.

Here are some example expressions using the arithmetic operators:

\begin{lstlisting}
1 + 2
1 - 2*3 - (4 - 7*6)
2.3 / 4.0
12.7 % 1.2
11 % 3
\end{lstlisting}

\subsection{Binary relational operators}

A binary relational operator takes two values, performs some comparison on them and then returns
a \code{bool} depending on the result of the comparison.

The relational operators available in Cesium are \code{<}, \code{>}, \code{<=}, \code{>=}, 
\code{==} and \code{!=}.

Here are some expression using these operators:

\begin{lstlisting}
1 < 2
12.1 >= 15.0
7 != 7
4i8 == 4i8
\end{lstlisting}

Each of them returns either \code{true} or \code{false} depending on whether the stated relation
holds or not.

\subsection{Ternary \textit{if} expressions}

An \code{if} expression in Cesium is an expression which takes one of two values, depending on the
outcome of a comparison. It is best illustrated with an example:

\begin{lstlisting}
if 1 < 2 then 3 else 4 end
\end{lstlisting}

This expression has the value \code{3} if \code{1 < 2}, otherwise it has the value \code{4}.

There is no requirement that an \code{if} expression must be all on one line. For example,
the following is equivalent to the above.

\begin{lstlisting}
if 1 < 2 then 
  3 
else 
  4 
end
\end{lstlisting}

This format also allows for additional lines of code to be inserted in each branch (see
\code{if} statements later in the documentation for examples). 

The expressions in each branch of an \code{if} expression must have the same type. This then 
becomes the type of the entire expression. Thus, for example, the type of the \code{if} 
expression in the above example is \code{int}.

For convenience, the \code{then} keyword may be elided in the multiline version of an \code{if}
expression:

\begin{lstlisting}
if 1 < 2
  3 
else 
  4 
end
\end{lstlisting}

\section{Variables and assignment}

\subsection{Global variables}

To define a variable in Cesium, one uses an assignment to assign a given value to that variable.
It is not necessary to declare variables in advance. They begin to exist at the moment they are
first assigned a value.

Here are some examples of assignment:

\begin{lstlisting}
s = 1
mytup = (1, 'c', "string")
v = s + 1
t = if s < 2 then 3 else 4 end
\end{lstlisting}

If a variable is defined at the top level (at the Cesium prompt), it is called a global variable
and its value can be used or changed anywhere after that point.

\subsection{Tuple assignment}

Sometimes it is convenient to be able to assign a whole lot of values at once. This can be done
with tuple assignment. For example, the following code defines variables \code{a}, \code{b} and 
\code{c} (if they don't already exist), and assigns the values \code{0}, \code{1} and 
\code{"string"}, respectively, to them:

\begin{lstlisting}
(a, b, c) = (0, 1, "string")
\end{lstlisting}

Note that tuple assignment is done efficiently by the compiler without actually creating a tuple.
It's simply syntactic sugar for multiple assignment.

\subsection{Tuple unpacking}

Sometimes one has a value which is a tuple and one wants to extract the values individually. This
is called tuple unpacking. 

For example, suppose that, at some point in our code, we have:

\begin{lstlisting}
t = (0, 1, "string")
\end{lstlisting}

We can extract the three values in the tuple \code{t} as follows:

\begin{lstlisting}
(a, b, c) = t
\end{lstlisting}

Now, \code{a} will have the value \code{0}, \code{b} the value \code{1} and \code{c} the value 
\code{"string"}.

Of course, the compiler does not actually create a tuple on the left hand side. It merely assigns
the three values from inside the tuple to the given variables.

Tuple assignment and unpacking can be combined, e.g.

\begin{lstlisting}
(a, b, (c, d)) = (1, 2, (3, 4))
\end{lstlisting}

Here tuple assignment is used to assign the values of \code{a} and \code{b} without creating a
tuple. Then the tuple \code{(3, 4)} is created and unpacked using tuple unpacking into \code{c}
and \code{d}. 

The compiler could optimise this case further by not creating the tuple \code{(3, 4)} and simply
assigning the values directly to \code{c} and \code{d}. However, this is not important as the
code above could also be written as follows, achieving the same thing efficiently:

\begin{lstlisting}
(a, b, c, d) = (1, 2, 3, 4)
\end{lstlisting}

\section{Control flow statements}

The path through a program is directed by control flow statements. We now discuss the various 
control flow statements available in Cesium.

\subsection{The \textit{if} statement}

The \code{if} statement executes a series of statements if a given condition is true.

Here is an example of code fragment incorporating an \code{if} statement:

\begin{lstlisting}
s = 1
t = 2
if s < 2
   t = t + 1
   s = t + 3
end
\end{lstlisting}

As with an \code{if} expression, the condition can be followed by the keyword \code{then}, and if 
the code that is to be executed is a simple statement, the entire thing can be written on one line:

\begin{lstlisting}
s = 1
if s < 2 then s = 3 end
\end{lstlisting}

The branch of an \code{if} statement does not define a new lexical scope. Thus variables defined 
inside the \code{if} statement also exist outside it.

No value is returned by an \code{if} statement, and so \code{none} will be printed after
evaluating an \code{if} statement at the Cesium prompt.

\subsection{The \textit{if}..\textit{else} statement}

The \code{if..else} statement executes the statements in one of two branches, depending on a given
condition.

Here is an example of code fragment incorporating an \code{if..else} statement:

\begin{lstlisting}
s = 1
t = 2
if s < 2
   t = t + 1
   s = t + 3
else
   s = 4
end
\end{lstlisting}

Note that a branch of an \code{if..else} statement does not define a new lexical scope. Thus
variables defined inside the \code{if..else} statement also exist outside it.

As with the \code{if} statement and \code{if} expression, the condition can be followed by the keyword
\code{then}, and if each branch only contains a single simple statement, then the entire thing can
be written on one line:

\begin{lstlisting}
s = 1
if s < 2 then s = 3 else s = 4 end
\end{lstlisting}

No value is returned by an \code{if..else} statement, and so \code{none} will be printed after
evaluating an \code{if..else} statement at the Cesium prompt.

Note that the branches of an \code{if..else} statement do not define a new lexical scope. Thus
variables defined inside a branch of an \code{if..else} statement also exist outside the statement.

Recall that an \code{if..else} statement whose branches both end in expressions (which must be of 
the same type) is called an \code{if} expression. An \code{if} expression does return a value, whose 
type is the same as that of the two expressions. 

Here is an example of a multi-line \code{if} expression.

\begin{lstlisting}
s = 1
t = 2
if s < 2
   t = t + 1
   s + t
else
   s = 4
   7
end
\end{lstlisting}

In this example, the \code{if} expression will have the value \code{4} because the first branch is 
taken and the final expression in that branch is \code{s + t}, which has the value \code{4}.

\subsection{The \textit{while} statement}

A simple loop in Cesium can be obtained with the \code{while} statement. It continues to execute its
body in a loop so long as a given condition is true.

Here is a simple example of a \code{while} loop:

\begin{lstlisting}
c = 0
s = 0
while c < 1000000 do
   s = s + c
   c = c + 1
end
\end{lstlisting}

If there is only a single simple expression in the body of a while loop, the entire thing can be
written on a single line. 

In the multiline version, the \code{do} keyword can be elided. Thus the example above can be written:

\begin{lstlisting}
c = 0
s = 0
while c < 1000000
   s = s + c
   c = c + 1
end
\end{lstlisting}

The body of a \code{while} statement does not define a new lexical scope. Thus variables defined 
inside the \code{while} statement also exist outside it.

A \code{while} statement does not return a value, and so \code{none} is printed if one is evaluated
at the Cesium prompt.

\section{User defined types}

\subsection{The \textit{type} declaration}

Just as a tuple is an anonymous type in Cesium, the user can define types with names using the
\code{type} statement.

The body of a type statement contains a list of fields, each of which is given a type. Any Cesium
or user defined type can be used for such a type declaration.

Here is a simple example of declaring a new type called \code{blah}.

\begin{lstlisting}
type blah
  a : int
  b : double
  c : (int, char, string)
end
\end{lstlisting}

This type contains three fields, \code{a} of type \code{int}, \code{b} of type \code{double} and
\code{c} which has the tuple type \code{(int, char, string)}.

Type declarations in Cesium can refer to other user defined types, even ones which don't exist 
yet. So long as the type is not instantiated before all the required types are defined, the compiler
will not complain about undefined type references.

Here is an example of a type referring to another type which is defined subsequently:

\begin{lstlisting}
type mytype1
  a : int
  b : mytype2
end

type mytype2
  c : int
  d : double
end
\end{lstlisting}

The advantage of a \code{type} declaration over a tuple is that the fields inside the type
can be referred to by name (see the dot operator below). 

\subsection{Default constructors}

Once a new type has been defined using a \code{type} statement, Cesium automatically creates a
default constructor for the type of the same name. A constructor is a function which takes a set of 
values as parameters and returns an instance of the newly defined type with those values inside.

For example, the \code{blah} type declaration above automatically creates a \code{blah} function
which can be called as follows:

\begin{lstlisting}
v = blah(1, 2.3, (2, 's', "hello"))
\end{lstlisting}

The value \code{v} now has type \code{blah} with the given data inside it.

\subsection{The dot operator}

Given a value whose type is user defined using a \code{type} statement, the individual fields of
the value can be accessed by name using the dot operator.

For example, to access the field \code{c} of the value \code{v} of type \code{blah} in the above
examples, we use the expression \code{v.c}.

Here are some examples of this:

\begin{lstlisting}
type circle
   x : int
   y : int
   radius : int
end

c = circle(20, 20, 10)
m1 = c.radius + c.x

c.x = 40
\end{lstlisting}

In the expression \code{m1}, we initially have that \code{c.x} has the value \code{20}. This value is
then used in the expression for \code{m1} before it is subsequently changed to \code{40}.  

Note that when a value of user defined type is assigned to another variable, the new variable points
to the same actual data. Thus modifying the fields of the second variable modifies the value of the 
original. 

For example:

\begin{lstlisting}
type t1
   x : int
end

c = t1(20)
d = c
d.x = 40
\end{lstlisting}

In this example, \code{c.x} starts with the value \code{20}. But \code{d.x} aliases the same data
and thus the final value of \code{c.x} is \code{40}.

\end{document}
