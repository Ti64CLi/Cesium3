%{
#include <stdio.h>
#include "ast.h"
#include "symbol.h"
#include "exception.h"

static int eat_eol = 0;

#define YYSTYPE ast_t *

/* 
   Increase the parse buffers
*/

#define YY_BUFFER_START_SIZE 16384 

#define YY_STACK_SIZE YY_BUFFER_START_SIZE

#define YY_INPUT(buf, result, max_size, core)          \
{                                                      \
  int yyc = fgetc(stdin);                              \
  if (yyc == EOF) { eat_eol = 0; longjmp(exc, 2); }    \
  if (eat_eol) while (yyc == '\n') yyc = fgetc(stdin); \
  if (yyc == '(') eat_eol++;                           \
  if (yyc == ')') eat_eol--;                           \
  result = (EOF == yyc) ? 0 : (*(buf)= yyc, 1);        \
}
%}

start         = Spacing r:GloStatement { root = r; }
                 | ( !EOL .)* EOL { root = NULL; eat_eol = 0; printf("Syntax error\n"); }
LocStatement  = Spacing IfStmt
                 | Spacing WhileStmt
                 | Spacing BreakStmt ';'
                 | Spacing ReturnStmt ';'
                 | Spacing Assignment ';'
                 | Spacing TupleAssign ';'
                 | Spacing TupleUnpack
                 | Spacing SlotAssign
                 | Spacing Expression ';'
                 | Spacing ';'
GloStatement  = Spacing FnStmt
                 | Spacing TypeStmt
                 | GloIfElseStmt
                 | LocStatement
Statement     = Spacing IfElseStmt
                 | LocStatement
Assignment    = i:Identifier Equals e:Expression { $$ = ast2(T_ASSIGN, i, e); }
TupleAssign   = i:LTuple Equals e:Tuple { $$ = ast2(T_TUPLE_ASSIGN, i, e); }
TupleUnpack   = i:LTuple Equals e:Expression { $$ = ast2(T_TUPLE_UNPACK, i, e); }
LTuple        = LParen r:LTupleBody RParen { $$ = ast1(T_TUPLE, r); }
LTupleBody    = r:LValue Comma s:LTupleBody { r->next = s; $$ = r; }
                | r:LValue Comma { $$ = r; }
                | LValue
LValue        = LSlot | LTuple | Identifier
SlotAssign    = i:LSlot Equals e:Expression { $$ = ast2(T_SLOT_ASSIGN, i, e); }
BlockBody     = s:Statement Spacing b:BlockBody { s->next = b; $$ = s; }
               | Statement
Block         = LBrace b:BlockBody RBrace { $$ = ast1(T_BLOCK, b); }
               | LBrace RBrace { $$ = ast1(T_BLOCK, NULL); }
               | Statement
BlockExprBody = s:Statement Spacing b:Block { s->next = b; $$ = s; }
               | Expression
BlockExpr     = LBrace BlockExprBody RBrace
               | Expression
IfStmt        = If LParen e:Expression RParen b:Block EOL
              { $$ = ast2(T_IF_STMT, e, ast1(T_THEN, b)); }
IfElseStmt    = If LParen e:Expression RParen b:Block Spacing Else c:Block
              { $$ = ast3(T_IF_ELSE_STMT, e, ast1(T_THEN, b), ast1(T_ELSE, c)); }
GloIfElseStmt = If LParen e:Expression RParen b:Block ( Space | Comment )* Else c:Block
              { $$ = ast3(T_IF_ELSE_STMT, e, ast1(T_THEN, b), ast1(T_ELSE, c)); }
IfElseExpr    = If LParen e:Expression RParen b:BlockExpr Spacing Else c:BlockExpr
              { $$ = ast3(T_IF_ELSE_EXPR, e, ast1(T_THEN, b), ast1(T_ELSE, c)); }
WhileStmt     = While LParen e:Expression RParen b:Block 
              { $$ = ast2(T_WHILE_STMT, e, ast1(T_DO, b)); }
BreakStmt     = Break { $$ = ast0(T_BREAK); }
TypeStmt      = Type i:Identifier LBrace r:TypeBody RBrace
              { $$ = ast2(T_TYPE_STMT, i, r); }
TypeBody      = r:TypeSlot ';' Spacing s:TypeBody { r->next = s->child; $$ = ast1(T_TYPE_BODY, r); }
               | r:TypeSlot ';' { $$ = ast1(T_TYPE_BODY, r); }
TypeSlot      = Spacing i:Identifier Colon r:TypeExpr { $$ = ast2(T_TYPE_SLOT, i, r); }
FnStmt        = Fn i:Identifier p:ParamList b:FnBlock { $$ = ast4(T_FN_PROTO, i, p, ast_nil, b); }
               | Fn i:Identifier p:ParamList Colon t:TypeExpr b:FnBlock { $$ = ast4(T_FN_PROTO, i, p, t, b); }
FnBlock       = LBrace b:BlockBody RBrace { $$ = ast1(T_BLOCK, b); }
               | LBrace RBrace { $$ = ast1(T_BLOCK, NULL); }
ParamList     = LParen p:ParamBody RParen 
               | LParen RParen { $$ = ast1(T_PARAM_BODY, NULL); }
ParamBody     = r:Param Comma s:ParamBody { r->next = s->child; $$ = ast1(T_PARAM_BODY, r); }
               | r:Param { $$ = ast1(T_PARAM_BODY, r); }
Param         = Spacing i:Identifier Colon r:TypeExpr { $$ = ast2(T_PARAM, i, r); }
ReturnStmt    = Return e:Expression { $$ = ast1(T_RETURN, e); }
               | Return { $$ = ast1(T_RETURN, ast_nil); }
TypeExpr      = Typename
              | TupleType
Typename      = !Reserved < IdentStart IdentCont* > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_TYPENAME, sym);
              }
TupleType     = LParen r:TupleTypeBody RParen { $$ = ast1(T_TUPLE_TYPE, r); }
TupleTypeBody = r:TypeExpr Comma s:TupleTypeBody { r->next = s; $$ = r; }
               | r:TypeExpr Comma { $$ = r; }
               | TypeExpr
ArgList       = r:Expression Comma s:ArgList { r->next = s; $$ = r; }
               | Expression
AOrS          = r:Identifier ( s:Appl { r = ast2(T_APPL, r, s); } 
                             | s:Slot { r = ast2(T_SLOT, r, s); } )+ { $$ = r; }
LSlot         = r:AOrS s:Slot { $$ = ast2(T_LSLOT, r, s); }
               | r:Identifier s:Slot { $$ = ast2(T_LSLOT, r, s); }
Appl          = LParen s:ArgList RParen { $$ = s; }
               | LParen RParen { $$ = NULL; }
Slot          = Dot i:SlotName { $$ = i; }
SlotName      = < IdentStart IdentCont* > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_SLOT_NAME, sym);
              }

Expression    = r:Infix40 ( ( EQ s:Infix40 { r = ast_binop(sym_lookup("=="), r, s); } )
               | ( NE s:Infix40 { r = ast_binop(sym_lookup("!="), r, s); } ) )* { $$ = r; } 
Infix40       = r:Infix20 ( ( LE s:Infix20 { r = ast_binop(sym_lookup("<="), r, s); } )
               | ( GE s:Infix20 { r = ast_binop(sym_lookup(">="), r, s); } ) 
               | ( LT s:Infix20 { r = ast_binop(sym_lookup("<"), r, s); } )
               | ( GT s:Infix20 { r = ast_binop(sym_lookup(">"), r, s); } ) )* { $$ = r; } 
Infix20       = r:Infix10 ( ( Plus s:Infix10 { r = ast_binop(sym_lookup("+"), r, s); } )
               | ( Minus s:Infix10 { r = ast_binop(sym_lookup("-"), r, s); } ) )* { $$ = r; }
Infix10       = r:Primary ( ( Times s:Primary { r = ast_binop(sym_lookup("*"), r, s); } )
               | ( Div s:Primary { r = ast_binop(sym_lookup("/"), r, s); } ) 
               | ( Mod s:Primary { r = ast_binop(sym_lookup("%"), r, s); } ) )* { $$ = r; }
Primary       = AOrS | Float | Double | UInt | Int | String | Char | Identifier
                 | ( LParen Expression RParen ) | Tuple | IfElseExpr
                
Reserved      = ( 'while' | 'if' | 'else' | 'type' | 'return' ) ![a-zA-Z0-9_]
TypeRes      = ( 'int' | 'uint'
                 | 'char' | 'string' | 'double' | 'float' ) ![a-zA-Z0-9_]
Tuple         = LParen r:TupleBody RParen { $$ = ast1(T_TUPLE, r); }
TupleBody     = r:Expression Comma s:TupleBody { r->next = s; $$ = r; }
                 | r:Expression Comma { $$ = r; }
                 | Expression
Identifier    = !Reserved !TypeRes < IdentStart IdentCont* > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_IDENT, sym);
              }
IdentStart    = [a-zA-Z_]
IdentCont     = IdentStart | [0-9]
Double        = < ( [1-9] [0-9]* | '0' ) '.' [0-9]* 
                ( ( 'e' | 'E' ) ( '+' | '-' )? ( [1-9] [0-9]* | '0' ) )? > 'd'? Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_DOUBLE, sym);
              } 
Float        = < ( [1-9] [0-9]* | '0' ) '.' [0-9]* 
                ( ( 'e' | 'E' ) ( '+' | '-' )? ( [1-9] [0-9]* | '0' ) )? > 'f' Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_FLOAT, sym);
              } 
Int           = < ( [1-9] [0-9]* | '0' ) > Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_INT, sym);
              }
UInt           = < ( [1-9] [0-9]* | '0' ) > ( 'U' | 'u' ) Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_UINT, sym);
              }
Char          = ( ['] < ![\\'"] . > ['] ) Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_CHAR, sym);
              }
              | ( ['] < [\\] [\\'"nrt0] > ['] )
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_CHAR, sym);
              }
String        = '"' < ( '\\\"' | ( !'"' . ) )* > '"' Spacing
              {
                 sym_t * sym = sym_lookup(yytext);
                 $$ = ast_symbol(T_STRING, sym);
              }
Spacing       = ( Space | EOL | Comment )*
Space         = ' ' | '\t'
Comment       = '/*' ( !'*/' . )* '*/'
Comma         = ',' Spacing
Colon         = ':' Spacing
Dot           = '.' Spacing
While         = 'while' Spacing
Break         = 'break' Spacing
If            = 'if' Spacing
Else          = 'else' Spacing
Type          = 'type' Spacing
Fn            = 'fn' Spacing
Return        = 'return' Spacing
Equals        = '=' Spacing
LParen        = '(' Spacing
RParen        = ')' Spacing 
LBrace        = '{' Spacing
RBrace        = Spacing '}' 
Plus          = '+' Spacing
Minus         = '-' Spacing
Times         = '*' Spacing
Div           = '/' Spacing
Mod           = '%' Spacing
EQ            = '==' Spacing
NE            = '!=' Spacing
LE            = '<=' Spacing
GE            = '>=' Spacing
LT            = '<' Spacing
GT            = '>' Spacing
EOL           = '\r\n' | '\n' | '\r'